import "@azure-tools/typespec-azure-core";
import "@azure-tools/typespec-azure-resource-manager";
import "@typespec/openapi";
import "@typespec/http";
import "@typespec/rest";

using Azure.Core;
using Azure.ResourceManager;
using OpenAPI;
using TypeSpec.Http;
using TypeSpec.Rest;

namespace Microsoft.AzureCis;

@doc("StorageAccountDsms properties.")
model StorageAccountDsmsResourceProperties {
  @doc("Name of the Storage Account.")
  accountName: string; // Camel case for the parameter names.

  @doc("Root path of the certificate.")
  rootPath: string;

  @doc("Defines in which region of dSMS to provision the Storage Account, such as global-dsms.dsms.%(HostNameSuffix), uswest-dsms.dsms.%(HostNameSuffix). Used only for provisioning Storage Account in non-home-dsms endpoint.")
  dsmsDns?: string; // Can be a part of provisioning ResultData output, and get PATCHed back from FRP.

  @doc("Account Replication Type.")
  accountReplicationType?: string;

  @doc("Description of the XStore account.")
  description?: string;

  @doc("Location of the Storage Account.")
  location?: string;

  @doc("Label of the XStore account.")
  label?: string;

  @doc("If False, create Storage Account and dSMS object in Deferred Provisioning; if True, create dSMS object in Provisioning, then create Storage Account in Deferred Provisioning and refresh keys in dSMS. Optional, True by default.")
  xstoreBootstrapping?: boolean;

  @doc("Name of the event to emit once the XStore account is created.")
  eventEmittedUponProvisioning?: string;

  @doc("Storage account whitelist in dSMS.")
  whitelists?: Whitelists;

  @doc("Storage account Replication in dSMS.")
  replicate?: Replicate;

  @doc("Set to True to block auto key rollover. Optional, False by default.")
  blockAutoRollover?: boolean;

  @doc("Override default key renewal period.")
  keyRenewalPeriodInDays?: int32;

  @doc("Set to True if you need ACL the Storage Account to Autopilot or PilotFish environments. Optional.")
  releaseKeyToAgent?: boolean;

  @doc("Set to True to force global sync of dSMS secret or False to skip it. Optional, False by default.")
  forceSyncGlobalDsmsSecret?: boolean;

  @doc("Storage Account resource provider. Acceptable values: 'Classic' (for RDFE Storage Accounts), 'ARM' (StorageV2 (general purpose v2) on Azure Portal), 'Xstore', 'Invalid' (used to create a dummy account in dSMS).")
  resourceProvider: "Classic" | "ARM" | "Xstore" | "Invalid" | string;

  @doc("Set to True to pilot XStore resource provider. In new region or new cloud scenario, it can create Storage Account at earlier stage before ARM ready. This is mainly as a replacement for Classic resource provider which will be deprecated with RDFE.")
  pilotXstoreResourceProvider?: boolean;

  @doc("Storage account shared access signature.")
  @Azure.ResourceManager.identifiers(#[])
  accountSasInfos?: Array<AccountSasInfo>;

  @doc("Residency boundary. Acceptable values: 'Worldwide', 'National'.")
  residencyBoundary?: "Worldwide" | "National" | string;

  @doc("Minimum account replication type, e.g. 'Standard_LRS'. If it's set, it will enable VRS feature for the Storage Account, and the 'AccountReplicationType' property will not be used.")
  resiliencyMinimum?: string;

  @doc("Maximum account replication type, e.g. 'Standard_ZRS'.")
  resiliencyMaximum?: string;

  @doc("Resiliencies progression id. Acceptable values: 'Default', 'PremiumDefault', 'Zonal'.")
  resilienciesProgressionId?: "Default" | "PremiumDefault" | "Zonal" | string;

  @doc("Additional locations to support resiliency, e.g. 'primary'.")
  additionalLocations?: string;

  @doc("Dual Stack Endpoint Preference.")
  dualStackEndpointPreference?: DualStackEndpointPreference;

  @doc("An array of Lifecycle Management Policy rules.")
  @Azure.ResourceManager.identifiers(#[])
  lifecycleManagementPolicy?: Array<LifecycleManagementPolicyRule>;

  @doc("Defines if Infrastructure Encryption is required.")
  requireInfrastructureEncryption?: boolean;

  #suppress "@azure-tools/typespec-azure-resource-manager/arm-resource-duplicate-property" "Duplicate property found in the resource envelope and resource properties."
  #suppress "@azure-tools/typespec-azure-resource-manager/no-empty-model" "Generic object model is used, because the number of nested properties can be different."
  @doc("Properties can be used to save customer key-value pairs associated with the dSMS secrets. Optional.")
  properties?: {};

  @doc("The Azure location.")
  azureLocation?: azureLocation;

  @doc("Provisioning status of the resource.")
  @visibility(Lifecycle.Read)
  provisioningState?: StorageAccountDsmsProvisioningState;

  @doc("Storage Account dSMS object name; a part of provisioning ResultData output.")
  @visibility(Lifecycle.Read) // A part of provisioning ResultData output, gets PATCHed back from FRP.
  storageAccountDsmsName?: string;

  @doc("Storage Account dSMS object resource provider; a part of provisioning ResultData output.")
  @visibility(Lifecycle.Read) // A part of provisioning ResultData output, gets PATCHed back from FRP.
  storageAccountDsmsResourceProviderName?: string;

  @doc("Storage Account ARM creation time; a part of provisioning ResultData output.")
  @visibility(Lifecycle.Read) // A part of provisioning ResultData output, gets PATCHed back from FRP.
  storageAccountArmCreationTime?: string;

  @doc("Storage Account RDFE creation time; a part of provisioning ResultData output.")
  @visibility(Lifecycle.Read) // A part of provisioning ResultData output, gets PATCHed back from FRP.
  storageAccountRdfeCreationTime?: string;

  @doc("Storage Account XStore creation time; a part of provisioning ResultData output.")
  @visibility(Lifecycle.Read) // A part of provisioning ResultData output, gets PATCHed back from FRP.
  storageAccountXstoreCreationTime?: string;

  #suppress "@azure-tools/typespec-azure-core/casing-style" "The names of Property types must use camelCase."
  @doc("DsmsAccountTemplate provision start time; a part of provisioning ResultData output.")
  @visibility(Lifecycle.Read) // A part of provisioning ResultData output, gets PATCHed back from FRP.
  provisionStartTime_dsmsAccountTemplate?: string;

  #suppress "@azure-tools/typespec-azure-core/casing-style" "The names of Property types must use camelCase."
  @doc("StorageAccountTemplate provision start time; a part of provisioning ResultData output.")
  @visibility(Lifecycle.Read) // A part of provisioning ResultData output, gets PATCHed back from FRP.
  provisionStartTime_storageAccountTemplate?: string;

  #suppress "@azure-tools/typespec-azure-core/casing-style" "The names of Property types must use camelCase."
  @doc("StorageAccountSyncTemplate provision start time; a part of provisioning ResultData output.")
  @visibility(Lifecycle.Read) // A part of provisioning ResultData output, gets PATCHed back from FRP.
  provisionStartTime_storageAccountSyncTemplate?: string;
}

@doc("Whitelist element defines the whitelist for a secret.")
model Whitelist {
  @doc("Type of the whitelist. ServiceID: whitelisting a service. SubscriptionID: whitelisting subscription ID for creating Storage Account objects. DnsDomain: whitelisting a DNS domain for creating chained certificates. ServiceTreeID: whitelisting a service tree ID.")
  type: string;

  @doc("Values of the whitelist, separated by semicolon.")
  values: string;
}

@doc("Whitelists element is a wrapper object over a collection of Whitelist elements.")
model Whitelists {
  @doc("Array of whitelists.")
  @Azure.ResourceManager.identifiers(#[])
  whitelist: Array<Whitelist>;
}

@doc("Replicate element defines where the secret should be replicated to.")
model Replicate {
  @doc("Local: This secret is not replicated to other dSMS instance. AllDsmsRegions: This secret can be replicated to all dSMS instances. SpecifiedDsmsRegions: This secret can only be replicated to the specified dSMS instances.")
  type: string;

  @doc("Regions the secret will be replicated to (Applicable when the type of replication is SpecifiedDsmsRegions). Regions are separated by semicolon.")
  regions: string;
}

@doc("AccountSasInfo element contains Sas Key Information.")
model AccountSasInfo {
  @doc("dSMS root folder.")
  rootPath: string;

  @doc("Name of the Storage Account.")
  name: string;

  @doc("Path in Dsms endpoint. If this specified, then RootPath and Name should be ignored.")
  dsmsLocation: string;

  @doc("The signed permissions for the account SAS. Acceptable values: Read (r), Write (w), Delete (d), List (l), Add (a), Create (c), Update (u) and Process (p).")
  signedPermissions: string;

  @doc("Services like blob(b), queue(q) and table(t).")
  signedServices: string;

  @doc("The signed resource types that are accessible with the account SAS. Service (s)/Container (c)/Object (o).")
  signedResourceTypes: string;
}

@doc("Lifecycle Management Policy Rule for Storage Account.")
model LifecycleManagementPolicyRule {
  @doc("Name of the policy rule.")
  name: string;

  @doc("Indicates whether the rule is enabled.")
  enabled: boolean;

  @doc("Policy for base blobs.")
  @Azure.ResourceManager.identifiers(#[])
  baseBlobPolicy: Array<LcmActionPolicy>;

  @doc("Policy for snapshots.")
  @Azure.ResourceManager.identifiers(#[])
  snapshotPolicy: Array<LcmActionPolicy>;

  @doc("Policy for versions.")
  @Azure.ResourceManager.identifiers(#[])
  versionPolicy: Array<LcmActionPolicy>;

  @doc("A string, containing BlobTypes to filter, separated with a semicolon. Acceptable values: 'blockBlob', 'appendBlob'.")
  blobTypesFilter: string;

  @doc("List of prefixes to filter by.")
  prefixMatchFilter: Array<string>;

  @doc("List of blob index match filters.")
  @Azure.ResourceManager.identifiers(#[])
  blobIndexMatchFilter: Array<BlobIndexMatch>;
}

@doc("Lifecycle Management Policy details for a specific action in a rule.")
model LcmActionPolicy {
  @doc("Action to be performed. Acceptable values: 'tierToCool', 'tierToArchive', 'tierToCold', 'tierToHot', 'delete'.")
  action: string;

  @doc("Days after modification greater than.")
  daysAfterModificationGreaterThan?: int32;

  @doc("Days after last access time greater than.")
  daysAfterLastAccessTimeGreaterThan?: int32;

  @doc("Days after last tier change greater than (specific to tierToArchive action).")
  daysAfterLastTierChangeGreaterThan?: int32;

  @doc("Days after creation greater than.")
  daysAfterCreationGreaterThan?: int32;
}

@doc("Blob Index Match filter.")
model BlobIndexMatch {
  @doc("Filter tag name.")
  name: string;

  @doc("Comparison operator.")
  operator: string;

  @doc("Filter tag value.")
  value: string;
}

@doc("Dual Stack Endpoint Preference.")
model DualStackEndpointPreference {
  @doc("Enable default dual stack endpoints.")
  defaultDualStackEndpoints?: boolean;

  @doc("Publish IPv4 endpoint.")
  publishIpv4Endpoint?: boolean;

  @doc("Publish IPv6 endpoint.")
  publishIpv6Endpoint?: boolean;
}

@doc("StorageAccount Resource")
model StorageAccountDsmsResource
  is ProxyResource<StorageAccountDsmsResourceProperties> { // This can be TrackedResource based on resourcetype.
  @doc("The name of resource.")
  @pattern("^[a-zA-Z0-9-]{3,80}$")
  @key("resourceName")
  @segment("storageAccountDsms") // Start with lower case. Should be plural.
  @visibility(Lifecycle.Read)
  @path
  name: string;
}

#suppress "@azure-tools/typespec-azure-resource-manager/no-resource-delete-operation" "The resource must have a delete operation.TypeSpec"
@armResourceOperations
interface StorageAccountDsms {
  createOrUpdate is ArmResourceCreateOrUpdateAsync<StorageAccountDsmsResource>;
  get is ArmResourceRead<StorageAccountDsmsResource>;
  listByResourceGroup is ArmResourceListByParent<StorageAccountDsmsResource>;
  listBySubscription is ArmListBySubscription<StorageAccountDsmsResource>;
}
