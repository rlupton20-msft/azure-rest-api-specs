import "@typespec/http";
import "@typespec/rest";
import "@typespec/versioning";
import "@azure-tools/typespec-azure-core";
import "@azure-tools/typespec-azure-resource-manager";

using TypeSpec.Http;
using TypeSpec.Rest;
using TypeSpec.Versioning;
using Azure.ResourceManager;

namespace Microsoft.Monitor;

@doc("Defines the properties of an SLI.")
model SliProperties {
  @doc("Represents good signals used in request-based SLI calculations.")
  goodSignals?: Signal;

  @doc("Represents total signals used in request-based SLI calculations.")
  totalSignals?: Signal;

  @doc("Signals used for window-based SLI calculations.")
  signals?: Signal;

  @doc("Defines the uptime criteria for window-based SLIs.")
  windowUptimeCriteria?: WindowUptimeCriteria;
}

@doc("Represents a signal model used in SLI calculations.")
model Signal {
  @doc("Sources of metrics used for SLIs.")
  @OpenAPI.extension("x-ms-identifiers", ["signalSourceId"])
  signalSources: SignalSource[];

  @doc("Mathematical formula used to combine multiple metrics.")
  signalFormula: string;
}

@doc("Represents a signal source used in SLIs.")
model SignalSource {
  @doc("Unique identifier for the signal source.")
  signalSourceId: string;

  @doc("Managed identity for authenticating the signal source.")
  sourceAmwAccountManagedIdentity: string;

  @doc("Resource ID of the source AMW account.")
  sourceAmwAccountResourceId: string;

  @doc("Namespace of the metric.")
  metricNamespace: string;

  @doc("Name of the metric.")
  metricName: string;

  @doc("Filters applied to modify signal values.")
  @OpenAPI.extension("x-ms-identifiers", ["logic", "conditions"])
  filters: Filter[];

  @doc("Defines how measurements are aggregated across multiple time series.")
  spatialAggregation: SpatialAggregation;

  @doc("Defines how measurements are aggregated over a specific time window within the same time series.")
  temporalAggregation?: TemporalAggregation;
}

@doc("Defines a filter model for signals.")
model Filter {
  @doc("Logical operator for filtering.")
  logic: Logic;

  @doc("Conditions applied to the filter.")
  @OpenAPI.extension("x-ms-identifiers", ["dimensionName", "value", "operator"])
  conditions: Condition[];
}

@doc("Defines logical operators used in filtering.")
union Logic {
  @doc("Logical AND operation.")
  "AND",

  @doc("Logical OR operation.")
  "OR",

  string,
}

@doc("Represents a filtering condition.")
model Condition {
  @doc("Dimension name used in filtering.")
  dimensionName?: string;

  @doc("Scalar function applied for filtering.")
  scalarFunction?: ScalarFunction;

  @doc("Defines the sampling type.")
  samplingType: SamplingType;

  @doc("Operator used in the filtering condition.")
  operator: ConditionOperator;

  @doc("Value used in filtering.")
  value: string;
}

@doc("Defines scalar functions used in filtering.")
union ScalarFunction {
  @doc("Maximum value.")
  "max",

  @doc("Minimum value.")
  "min",

  @doc("Average value.")
  "avg",

  @doc("Summation.")
  "sum",

  string,
}

@doc("Defines the available sampling types.")
union SamplingType {
  @doc("Maximum value.")
  "max",

  @doc("Minimum value.")
  "min",

  @doc("Average value.")
  "avg",

  @doc("Summation.")
  "sum",

  string,
}

@doc("Defines operators used in filter conditions.")
union ConditionOperator {
  @doc("Equal to.")
  "eq",

  @doc("Not equal to.")
  "ne",

  @doc("Less than.")
  "lt",

  @doc("Less than or equal to.")
  "lte",

  @doc("Greater than.")
  "gt",

  @doc("Greater than or equal to.")
  "gte",

  @doc("In.")
  in: "@in",

  @doc("Not in.")
  "!in": "notin",

  @doc("Starts with.")
  "startswith",

  @doc("Does not start with.")
  "!startswith": "notstartswith",

  @doc("Contains the value.")
  "contains",

  @doc("Does not contain the value.")
  "!contains": "notcontains",

  string,
}

@doc("Represents the spatial aggregation model.")
model SpatialAggregation {
  @doc("Type of spatial aggregation.")
  type: AggregationType;

  @doc("Dimensions considered for spatial aggregation.")
  dimensions: string[];
}

@doc("Defines the available aggregation types.")
union AggregationType {
  @doc("Average value.")
  "Average",

  @doc("Minimum value.")
  "Min",

  @doc("Maximum value.")
  "Max",

  @doc("Summation.")
  "Sum",

  @doc("Count of occurrences.")
  "Count",

  string,
}

@doc("Represents criteria for determining uptime in window-based SLIs.")
model WindowUptimeCriteria {
  @doc("Threshold value used to determine uptime.")
  @minValue(0)
  target: float32;

  @doc("Comparison operator used for uptime evaluation.")
  comparator: WindowUptimeCriteriaComparator;
}

@doc("Defines comparison operators for window uptime criteria.")
union WindowUptimeCriteriaComparator {
  @doc("Less than the target value.")
  "lt",

  @doc("Greater than the target value.")
  "gt",

  @doc("Less than or equal to the target value.")
  "lte",

  @doc("Greater than or equal to the target value.")
  "gte",

  string,
}

@doc("Represents temporal aggregation settings.")
model TemporalAggregation {
  @doc("Type of temporal aggregation.")
  type: AggregationType;

  @doc("Time window size for aggregation, in minutes.")
  windowSizeMinutes: int32;
}
