import { existsSync, mkdirSync, readdirSync, readFileSync, rmSync, writeFileSync} from "fs";
import { basename, dirname, resolve } from "path"
import { execSync } from "child_process"
import * as crypto from "node:crypto";

import { apiVersions, dataPlanePackageNames, validatePackage } from "./common.mjs";
import _ from "lodash";

const getPathForOperationId = ({swaggerObject, operationId}) => {
  for(const [basePath, operations] of Object.entries(swaggerObject.paths)) {
    for(const [operationName, operationDetails] of Object.entries(operations)) {
      if(operationDetails.operationId === operationId) {
        return basePath
      }
    }
  }
  console.warn (`Unable to find operation "${operationId}"`)
  // throw new Error(`Unable to find operation "${operationId}"`)
}

const fixIds = ({ swaggerObject, exampleObject, operationId}) => {

    let basePath = getPathForOperationId({
      swaggerObject,
      operationId,
    })
  if(!basePath) {
    console.warn(`Unable to find base path "${basePath}"`)
    return exampleObject
  }
  for(const [returnCode, { body, ...rest }] of Object.entries(exampleObject.responses)) {
    if(!body) {
      continue
    }
    const {id, name, ...bodyRest } = body
    for(const [propName, propVal] of Object.entries(exampleObject.parameters)) {
      basePath = basePath.replaceAll(`{${propName}}`, propVal)
    }
    if(basePath.indexOf(":") > 0) {
      basePath = basePath.substring(0, basePath.indexOf(":"))
    }
    if(basePath.indexOf("/operations/") > 0) {
      basePath = basePath.substring(0, basePath.indexOf("/operations/"))
    }
    let _name = basePath.substring(basePath.lastIndexOf("/") + 1)
    // if(_name.indexOf(":") > 0) {
    //   _name = _name.substring(0, _name.indexOf(":"))
    // }

    if(Object.keys(body).length > 0) {
      exampleObject.responses[returnCode] = {
        ...rest,
        body: {
          id: id ? basePath : undefined,
          name:  name && _name ? _name : name,
          ...bodyRest,
          value: Array.isArray(body?.value) ? body.value.map(({ id, name, ..._val }) => ({
            id: id && name ? `${basePath}/${name}` : undefined,
            name,
            ..._val,
          })) : undefined,
        }

      }
    }
  }
  return exampleObject
}

const runMain = () => {
  console.log("***********************************")
  const dirs = []
  const makeDirs  = () => {
    for( const apiVersion of apiVersions ) {
      dirs.push({
        inDir:
          `specification/sciencedev/resource-manager/Private.Science/preview/${apiVersion}/examples`,
        outDir:
          `specification/sciencedev/Science.Management/examples/${apiVersion}`,
      });
      for(const dpPackageName of dataPlanePackageNames) {
        dirs.push( {
          inDir: `specification/sciencedev/data-plane/Microsoft.Science.${dpPackageName}/preview/${apiVersion}/examples`,
          outDir:
            `specification/sciencedev/Science.${dpPackageName}/examples/${apiVersion}`,
        })
      }
    }
    return dirs;

  }
  for(const { inDir, outDir } of makeDirs()) {
    const outDirPath = resolve(outDir)

    const swaggerDir = resolve(dirname(inDir))
    console.log("swaggerDir: ",swaggerDir)
    let swaggerFile = ""
    for(const file of readdirSync(swaggerDir)) {
      if(file.endsWith(".json")) {
        swaggerFile = resolve(swaggerDir, file)
      }
    }
    if(!swaggerFile) {
      throw new Error("No specification file found")
    }
    const swaggerObject = JSON.parse(readFileSync(swaggerFile))
    // console.log("swaggerFile: ",swaggerFile)

    console.log("\nDeleting:", outDirPath)
    rmSync(outDirPath, { recursive: true, force : true })
    mkdirSync(outDirPath)
    console.log("\n------------------------")
    console.log("Processing: ", inDir)
    for(const file of readdirSync(inDir)) {
      if(!file.endsWith("_Gen.json")) {
        continue;
      }
      const filePath = resolve(inDir, file);
      console.log("   - ", file)
      let {title, ...contents} = JSON.parse(readFileSync(filePath, "utf8"));
      if(title.indexOf("] rule") > 0) {
        title = title.substring(0,title.indexOf("] rule")+ ("] rule".length))
      }
      if(file.includes("_MaximumSet")) {
        title = title.replaceAll("MinimumSet", "MaximumSet");
        if(!title.endsWith(" - generated by [MaximumSet] rule")) {
          title = `${title} - generated by [MaximumSet] rule`
        }

      } else if(file.includes("_MinimumSet")) {
        title = title.replaceAll("MaximumSet", "MinimumSet");
        if(!title.endsWith(" - generated by [MinimumSet] rule")) {
          title = `${title} - generated by [MinimumSet] rule`
        }
      }
      if(contents.parameters) {
        for(const [key, value] of Object.entries(contents.parameters)) {
          if(key.endsWith("Name") && value === "Replace this value with a string matching RegExp ^[a-zA-Z0-9-]{3,24}$") {
            contents.parameters[key] = crypto.randomBytes(9).toString('hex')
          }
        }
      }
      // else {
      //   console.log(`---- ${filePath} no parameters?`)
      // }
      try {
        fixIds({ swaggerObject, exampleObject: contents, operationId: contents.operationId })
      } catch(err) {
        console.log(`Failed to fox IDs for ${file}: ${err.message}`)
        throw err;
      }
      writeFileSync(
        filePath,
          JSON.stringify({
          title,
          ...contents,
        }, null, 2)
      )
      writeFileSync(
        resolve(outDirPath, file),
        JSON.stringify({
          title,
          ...contents,
        }, null, 2)
      )
    }
  }
  // import("./validate-all.mjs")
}

runMain()
